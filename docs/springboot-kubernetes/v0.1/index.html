<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Caching SpringBoot Microservices with Hazelcast in Kubernetes :: Hazelcast Guides</title>
    <link rel="canonical" href="https://hazelcast.org/springboot-kubernetes/v0.1/index.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://hazelcast.org">Hazelcast Guides</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="https://hazelcast.org/">hazelcast.org</a>
          </span>
        </div -->
        <a class="navbar-item" href="https://hazelcast.org/">hazelcast.org</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<!-- <div class="nav-container" data-component="springboot-kubernetes" data-version="v0.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">SpringBoot + Kubernetes</span>
    <span class="version">v0.1</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Hazelcast + SpringBoot</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../springboot-embedded/v0.1/index.html">v0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Hazelcast Guides</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../guides-home/v0.1/index.html">v0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Microprofile + Kubernetes</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../microprofile-kubernetes/v0.1/index.html">v0.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">SpringBoot + Kubernetes</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">v0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Templates</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../templates/v0.1/index.html">v0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
 -->
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../guides-home/v0.1/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<!-- 
  <div class="edit-this-page"><a href="https://github.com/hazelcast-guides/caching-springboot-microservices-on-kubernetes/edit/antora-doc/antora/modules/ROOT/pages/index.adoc">Edit this Page</a></div>
  -->
</div>
  <div class="content">
<article class="guide-content">
<h1 class="page">Caching SpringBoot Microservices with Hazelcast in Kubernetes</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>You can see the whole project <a href="https://github.com/hazelcast-guides/caching-springboot-microservices-on-kubernetes">here.</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_youll_learn"><a class="anchor" href="#_what_youll_learn"></a>What you&#8217;ll learn</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You will learn how to use Hazelcast distributed caching with SpringBoot and deploy to a local Kubernetes cluster.
You will then create a Kubernetes Service which load balance between containers and verify that you can share data between Microservices.</p>
</div>
<div class="paragraph">
<p>The microservice you will deploy is called <code>hazelcast-spring</code>. The <code>hazelcast-spring</code> microservice simply
helps you put a data and read it back. As Kubernetes Service will send the request to different pod each time
you initiate the request, the data will be served by shared hazelcast cluster between <code>hazelcast-spring</code> pods.</p>
</div>
<div class="paragraph">
<p>You will use a local single-node Kubernetes cluster. However, you can deploy this application on any kubernetes distributions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_hazelcast"><a class="anchor" href="#_what_is_hazelcast"></a>What is Hazelcast?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast is an open source In-Memory Data Grid (IMDG). It provides elastically scalable distributed In-Memory computing,
widely recognized as the fastest and most scalable approach to application performance.</p>
</div>
<div class="paragraph">
<p>Hazelcast is designed to scale up to hundreds and thousands of members.
Simply add new members and they will automatically discover the cluster
and will linearly increase both memory and processing capacity.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_spring_boot"><a class="anchor" href="#_why_spring_boot"></a>Why Spring Boot?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
To learn more about Spring Boot, visit <a href="http://spring.io/projects/spring-boot">website.</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before you begin, have the following tools installed:</p>
</div>
<div class="paragraph">
<p>First, you will need Apache Maven to build and run the project.</p>
</div>
<div class="paragraph">
<p>Also you will need a containerization software for building containers. Kubernetes supports a variety
of container types. You will use <code>Docker</code> in this guide. For installation instructions, refer to the <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">official Docker documentation</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><span class="system"><strong>Windows</strong> | <strong>Mac</strong></span></p>
</div>
<div class="paragraph">
<p>Use Docker Desktop, where a local Kubernetes environment is pre-installed and enabled. If you do not see the Kubernetes tab then you have an older version of Docker Desktop; upgrade to the latest version.</p>
</div>
<div class="paragraph">
<p>Complete the setup for your operating system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set up  <a href="https://docs.docker.com/docker-for-windows/#kubernetes" target="_blank" rel="noopener">Docker for Windows</a>.
On the Docker for Windows <em>General Setting</em> page, ensure that the option <code>Expose daemon on
tcp://localhost:2375 without TLS</code> is enabled. This is required by the <code>dockerfile-maven</code>
part of the build.</p>
</li>
<li>
<p>Set up <a href="https://docs.docker.com/docker-for-mac/#kubernetes" target="_blank" rel="noopener">Docker for Mac</a>.</p>
</li>
<li>
<p>After following one of the sets of instructions, ensure that Kubernetes (not Swarm) is selected as the orchestrator in Docker Preferences.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="system"><strong>Linux</strong></span></p>
</div>
<div class="paragraph">
<p>You will use <code>Minikube</code> as a single-node Kubernetes cluster that runs locally in a virtual machine.
For Minikube installation instructions see the <a href="https://github.com/kubernetes/minikube#installation" target="_blank" rel="noopener">minikube installation instructions</a>. Make sure to pay attention to the requirements as they vary by platform.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started"><a class="anchor" href="#_getting_started"></a>Getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The fastest way to work through this guide is to clone the Git repository and use the project provided inside:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ > git clone https://github.com/hazelcast-guides/caching-springboot-microservices-on-kubernetes
$ > cd caching-springboot-microservices-on-kubernetes</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>initial</code> directory contains the starting project that you will build upon.</p>
</div>
<div class="paragraph">
<p>The <code>final</code> directory contains the finished project that you will build.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_spring_application"><a class="anchor" href="#_running_spring_application"></a>Running Spring Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The application in initial directory is a basic SpringBoot app having 3 endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>"/"</strong> is the homepage returning "Welcome" string only</p>
</li>
<li>
<p><strong>"/put"</strong> is the page where key and values can be put on a concurrent hash map.</p>
</li>
<li>
<p><strong>"/get"</strong> is the page where the values in the map can be obtained by keys.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Build the app using Maven in the <code>initial</code> directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; mvn package</pre>
</div>
</div>
<div class="paragraph">
<p>Run the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; java -jar target/hazelcast-spring-app-0.1.0.jar</pre>
</div>
</div>
<div class="paragraph">
<p>Now your app is runnning on localhost:8080. You can test by following requests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; curl "localhost:8080"
$ &gt; curl "localhost:8080/put?key=key1&amp;value=hazelcast"
$ &gt; curl "localhost:8080/get?key=key1"</pre>
</div>
</div>
<div class="paragraph">
<p>This part was the introduction of the application. You can stop your application by CTRL + C.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dockerizing_the_app"><a class="anchor" href="#_dockerizing_the_app"></a>Dockerizing the App</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To create the docker image of the application, add following line into pom.xml file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;!-- add among other properties --&gt;
&lt;properties&gt;
 	&lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;
&lt;/properties&gt;

&lt;!-- add among other plugins --&gt;
&lt;plugins&gt;
&lt;plugin&gt;
      &lt;groupId&gt;com.spotify&lt;/groupId&gt;
      &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;${version.dockerfile-maven-plugin}&lt;/version&gt;
      &lt;configuration&gt;
         &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;
      &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Then create the Dockerfile under <code>initial</code> directory named "Dockerfile" containing the instructions for creating a docker image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FROM openjdk:8-jdk-alpine

VOLUME /tmp

ARG JAR_FILE=target/hazelcast-spring-app-0.1.0.jar

ADD ${JAR_FILE} hazelcast-spring-demo.jar

ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/hazelcast-spring-demo.jar"]</pre>
</div>
</div>
<div class="paragraph">
<p>Before creating the Docker image of the app, first rebuild the app:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; mvn clean package</pre>
</div>
</div>
<div class="paragraph">
<p>Then create image file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; docker build -t hazelcast-spring-demo .</pre>
</div>
</div>
<div class="paragraph">
<p>Now, the image must be seen among the docker images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; docker images

REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
hazelcast-spring-demo                latest              5f65a62b0aa0        19 seconds ago      122MB
openjdk                              8-jdk-alpine        a3562aa0b991        5 weeks ago         105MB
k8s.gcr.io/kube-proxy-amd64          v1.10.11            7387003276ac        6 months ago        98.3MB
k8s.gcr.io/kube-apiserver-amd64      v1.10.11            e851a7aeb6e8        6 months ago        228MB</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_the_app_in_container"><a class="anchor" href="#_running_the_app_in_container"></a>Running the app in container</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that the Docker image is ready, check if the image runs properly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; docker run -p 5000:8080 hazelcast-spring-demo</pre>
</div>
</div>
<div class="paragraph">
<p>Test the app on the port 5000:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; curl "localhost:5000"
$ &gt; curl "localhost:5000/put?key=key1&amp;value=hazelcast"
$ &gt; curl "localhost:5000/get?key=key1"</pre>
</div>
</div>
<div class="paragraph">
<p>If you see the same responses as the ones you get when the app is run without container, that means it’s all OK with the image.
To stop the container, get the container ID first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; docker ps</pre>
</div>
</div>
<div class="paragraph">
<p>Then find the application&#8217;s container ID and stop the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; docker stop [CONTAINER-ID]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_starting_and_preparing_your_cluster_for_deployment"><a class="anchor" href="#_starting_and_preparing_your_cluster_for_deployment"></a>Starting and preparing your cluster for deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that you have a proper docker image, deploy the app to kuberntes pods. Start your Kubernetes cluster first.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><span class="system"><strong>Windows</strong> | <strong>Mac</strong></span></p>
</div>
<div class="paragraph">
<p>Start your Docker Desktop environment. Make sure "Docker Desktop is running" and "Kubernetes is running" status are updated.</p>
</div>
<div class="paragraph">
<p><span class="system"><strong>Linux</strong></span></p>
</div>
<div class="paragraph">
<p>Run the following command from a command line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ > minikube start</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validate_kubernetes_environment"><a class="anchor" href="#_validate_kubernetes_environment"></a>Validate Kubernetes environment</h3>
<div class="paragraph">
<p>Next, validate that you have a healthy Kubernetes environment by running the following command from the command line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; kubectl get nodes</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command should return a <code>Ready</code> status for the master node.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><span class="system"><strong>Windows</strong> | <strong>Mac</strong></span></p>
</div>
<div class="paragraph">
<p>You do not need to do any other step.</p>
</div>
<div class="paragraph">
<p><span class="system"><strong>Linux</strong></span></p>
</div>
<div class="paragraph">
<p>Run the following command to configure the Docker CLI to use Minikube&#8217;s Docker daemon.
After you run this command, you will be able to interact with Minikube&#8217;s Docker daemon and build new
images directly to it from your host machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; eval $(minikube docker-env)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After you’re sure that a master node is ready, create kubernetes.yaml under initial directory with the same content in the final/kubernetes.yaml file.
This file defines two Kubernetes resources: one statefulset and one service. StatefulSet is preferred solution for Hazelcast because it enables controlled scale out/in of your microservices for easy data distribution. To learn more about StatefulSet, you can
visit <a href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/">Kubernetes documentation.</a></p>
</div>
<div class="paragraph">
<p>By default, we create 2 replicas of <code>hazelcast-spring</code> microservice behind the <code>hazelcast-spring-service</code> which forwards
requests to one of the pods available in the kubernetes cluster.</p>
</div>
<div class="paragraph">
<p><code>MY_POD_NAME</code> is an environment variable made available to the pods so that each microservice knows which pod they are in.
This is going to be used in this guide in order to show which pod is responding to the http request.</p>
</div>
<div class="paragraph">
<p>Run the following command to deploy the resources as defined in kubernetes.yaml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl apply -f kubernetes.yaml</pre>
</div>
</div>
<div class="paragraph">
<p>Run the following command to check the status of your pods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl get pods</pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll see an output similar to the following if all the pods are healthy and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>NAME                             READY     STATUS    RESTARTS   AGE
hazelcast-spring-statefulset-0   1/1       Running   0          7s
hazelcast-spring-statefulset-1   1/1       Running   0          5s</pre>
</div>
</div>
<div class="paragraph">
<p>Send request to port :31000 and see the pods responding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; curl localhost:31000</pre>
</div>
</div>
<div class="paragraph">
<p>And add a value to the map and then get the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; curl "localhost:31000/put?key=key1&amp;value=hazelcast"

{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; the second pod's response

$ &gt; while true; do curl localhost:31000/get?key=key1;echo; sleep 2; done

{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; the second pod's response
{"value":null,"podName":"hazelcast-spring-statefulset-0"} --&gt; the first pod's response
{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; the second pod's response
{"value":null,"podName":"hazelcast-spring-statefulset-0"} --&gt; the first pod's response</pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, data is not shared between nodes. Here is where Hazelcast comes into action.
Kill active pods under <code>initial</code> directory by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl delete -f kubernetes.yaml</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hazelcast_caching_among_kubernetes_pods"><a class="anchor" href="#_hazelcast_caching_among_kubernetes_pods"></a>Hazelcast Caching among Kubernetes pods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now we will use Hazelcast Caching among the pods. Update the pom.xml file by adding those dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;dependency&gt;
            &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
            &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
            &lt;version&gt;${version.hazelcast}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
            &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
            &lt;artifactId&gt;hazelcast-kubernetes&lt;/artifactId&gt;
            &lt;version&gt;${version.hazelcast-kubernetes}&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Then modify the CommandController.java such that Hazelcast is used in the map. Also add Hazelcast config to Application.java file and hazelcast libraries as well.
Those versions are the ones under <code>final</code> folder.</p>
</div>
<div class="paragraph">
<p>Rebuild the app and create new image:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; mvn clean package
$ &gt; docker build -t hazelcast-spring-demo .</pre>
</div>
</div>
<div class="paragraph">
<p>Before deploying on kubernetes, create rbac.yaml file as in the <code>final</code> directory. Role Based Access Controller(RBAC) configuration is used to give access to Kubernetes Master API from pods which runs microservices. Hazelcast requires a read access to autodiscover other hazelcast members and form hazelcast cluster.</p>
</div>
<div class="paragraph">
<p>Run the following commands to deploy the resources as defined in kubernetes.yaml and rbac.yaml in the specified order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl apply -f rbac.yaml
$ &gt; kubectl apply -f kubernetes.yaml</pre>
</div>
</div>
<div class="paragraph">
<p>Run the following command to check the status of your pods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl get pods</pre>
</div>
</div>
<div class="paragraph">
<p>You should also check if hazelcast cluster is formed by checking one of the pod’s log file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl logs hazelcast-spring-statefulset-1</pre>
</div>
</div>
<div class="paragraph">
<p>You must see such a response at the end of the log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Members {size:2, ver:2} [
	Member [10.1.0.52]:5701 - ac54036d-c16f-40ae-9531-93e6f0683cf9 this
	Member [10.1.0.53]:5701 - d963bb82-3842-49fd-a522-82c8543bdb9d
]</pre>
</div>
</div>
<div class="paragraph">
<p>If it&#8217;s not seen, wait for  pods to be configured and try again.</p>
</div>
<div class="paragraph">
<p>Now we expect all nodes to give the same value for the same key put on the map via one pod only. Let&#8217;s try:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; curl "http://localhost:31000/put?key=key1&amp;value=hazelcast"

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; pod1 responsed

$ &gt; while true; do curl localhost:31000/get?key=key1;echo; sleep 2; done

	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; pod1 responsed
	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"} --&gt; pod1 responsed
	{"value":"hazelcast","podName":"hazelcast-spring-statefulset-0"} --&gt; pod0 responsed</pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, the insertion is made on hazelcast-spring-statefulset-1 but both nodes gives the same value for the key now.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scaling_with_hazelcast"><a class="anchor" href="#_scaling_with_hazelcast"></a>Scaling with Hazelcast</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scale the cluster with one more pod and see that you still retrieve the shared data.</p>
</div>
<div class="listingblock command">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; kubectl scale statefulset hazelcast-spring-statefulset --replicas=3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run following command to see the latest status of the pods</p>
</div>
<div class="listingblock command">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; kubectl get pods</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, a new pod <code>hazelcast-spring-statefulset-2</code> has joined to the cluster.</p>
</div>
<div class="listingblock no_copy">
<div class="content">
<pre class="highlightjs highlight"><code>NAME                              READY     STATUS    RESTARTS   AGE
hazelcast-spring-statefulset-0   1/1       Running   0          8m
hazelcast-spring-statefulset-1   1/1       Running   0          8m
hazelcast-spring-statefulset-2   1/1       Running   0          31s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the following command again to see the output</p>
</div>
<div class="listingblock command">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; while true; do curl http://localhost:31000/get?key=key1;echo; sleep 2; done</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>{"value":"hazelcast","podName":"hazelcast-spring-statefulset-2"}
{"value":"hazelcast","podName":"hazelcast-spring-statefulset-0"}
{"value":"hazelcast","podName":"hazelcast-spring-statefulset-2"}
{"value":"hazelcast","podName":"hazelcast-spring-statefulset-1"}</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, <code>hazelcast-caching-statefulset-2</code> is returning correct data.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_microservices_running_on_kubernetes"><a class="anchor" href="#_testing_microservices_running_on_kubernetes"></a>Testing microservices running on Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a testing class under <code>initial/src/test/java/it/io/spring/guides/hazelcast/</code>
named <code>HazelcastCachingIT.java</code> .The contents of the test file is available under <code>final</code> directory.</p>
</div>
<div class="paragraph">
<p>The test makes sure that the <strong>/put</strong> endpoint is handled by one pod and <strong>/get</strong> methods returns the same data from the other kubernetes pod.</p>
</div>
<div class="paragraph">
<p>It first puts a key/value pair to hazelcast-spring microservice and keeps podname in the firstpod variable. In the second part, tests submits multiple <strong>/get</strong> requests until to see that podname is different then the pod which initially handled <strong>/put</strong> request.</p>
</div>
<div class="paragraph">
<p>In order to run integration tests, you must have a running hazelcast-spring microservices in minikube environment. As you have gone through all previous steps, you already have it.</p>
</div>
<div class="paragraph">
<p>Navigate back to <code>initial</code> directory and run the test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; mvn -Dtest=HazelcastCachingIT test</pre>
</div>
</div>
<div class="paragraph">
<p>If the tests pass, you’ll see a similar output to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running HazelcastCachingIT
10:12:27.087 [Time-limited test] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://localhost:31000/put?key=key1&amp;value=hazelcast-spring-guide
10:12:27.175 [Time-limited test] DEBUG org.springframework.web.client.RestTemplate - Accept=[application/json, application/*+json]
10:12:27.312 [Time-limited test] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK
...
...
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.354 s - in HazelcastCachingIT
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tearing_down_the_environment"><a class="anchor" href="#_tearing_down_the_environment"></a>Tearing down the environment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you no longer need your deployed microservices, you can delete all Kubernetes resources by running the kubectl delete command: You might need to wait up to 30 seconds as stateful sets kills pods one at a time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ &gt; kubectl delete -f kubernetes.yaml</pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><span class="system"><strong>Windows</strong> | <strong>Mac</strong></span></p>
</div>
<div class="paragraph">
<p>Nothing more needs to be done for Docker Desktop.</p>
</div>
<div class="paragraph">
<p><span class="system"><strong>Linux</strong></span></p>
</div>
<div class="paragraph">
<p>Perform the following steps to return your environment to a clean state.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Point the Docker daemon back to your local machine:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; eval $(minikube docker-env -u)</code></pre>
</div>
</div>
</li>
<li>
<p>Stop your Minikube cluster:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; minikube stop</code></pre>
</div>
</div>
</li>
<li>
<p>Delete your cluster:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ &gt; minikube delete</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_great_work_youre_done"><a class="anchor" href="#_great_work_youre_done"></a>Great work! You’re done!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You have just run a SpringBoot application and created its Docker image. First you runned the app on a container and then deployed it to Kubernetes. You then added Hazelcast caching to the hazelcast-spring, tested with a simple curl command. You also scaled out the microservices and saw that data is shared between microservices. As a last step, you ran integration tests against hazelcast-spring that was deployed in a Kubernetes cluster.</p>
</div>
</div>
</div>
</article>
<!-- <aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
 -->
  </div>
</main>
</div>
<footer class="footer">
  <a href="https://www.hazelcast.org" class="icon">
    <img src="../../_/img/hazelcast.png" alt="Hazelcast">
  </a>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
